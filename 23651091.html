<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="SuPQ3DDNV0"><meta name="author" content="Minhui Zheng, mattzhengjob@gmail.com"><title>聊聊柯里化 · Minhui's blog</title><meta name="description" content="最近在看柯里化（currying），发现网上的资料众说纷纭，鱼龙混杂。再加上也算是一道高频面试题，所以也试试实现了一下，顺便记录一下心得。
首先明确一点，currying 的定义，根据 wiki 的解释，柯里化是一种将接受多参数函数转换成一个接受单一序列参数的函数（ currying is the "><meta name="keywords" content="Hexo,HTML,JavaScript,CSS,Frontend,Angular,React,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/custom.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-96963741-1', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Minhui's blog</a></h3><div class="description"><p>Live long and prosper.</p></div></div></div><ul class="social-links"><li><a href="https://github.com/zhengminhui" target="_blank"><i class="fa fa-github"></i></a></li><li><a href="http://instagram.com/wanzaiwanger" target="_blank"><i class="fa fa-instagram"></i></a></li><li><a href="http://weibo.com/alandwhatever" target="_blank"><i class="fa fa-weibo"></i></a></li><li><a href="http://twitter.com/wanzaiwanger" target="_blank"><i class="fa fa-twitter"></i></a></li></ul><div class="footer"><span>Theme by CaiCai & Ben</span><div class="by_farbox"><span>Proudly published with Hexo</span></div><span><i class="fa fa-user">&nbsp;</i><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></span> visitors | </span><i class="fa fa-eye">&nbsp;</i><span id="busuanzi_container_site_pv"><span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i></span> views</span></span></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="https://secure.gravatar.com/avatar/c85f5cf8f290742d2e21e929f89a5215?s=200"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>聊聊柯里化</a></h3></div><div class="post-content"><p>最近在看柯里化（currying），发现网上的资料众说纷纭，鱼龙混杂。再加上也算是一道高频面试题，所以也试试实现了一下，顺便记录一下心得。</p>
<p>首先明确一点，currying 的定义，根据 wiki 的解释，柯里化是一种将接受多参数函数转换成一个接受单一序列参数的函数（ currying is the technique of conveting a function that takes multiple arguments into a sequence of functions that each take a single arguments. ）</p>
<p>数学表达式：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x= f(a,b,c)  becomse :</span><br><span class="line"></span><br><span class="line">h = g(a);</span><br><span class="line"></span><br><span class="line">i = h(b);</span><br><span class="line"></span><br><span class="line">x = i(c);</span><br><span class="line"></span><br><span class="line">或者可以链式调用 x = g(a)(b)(c).</span><br></pre></td></tr></table></figure>
<p>根据定义我们可以得知，currying 需要函数有一个固定数量入参，这样才能将对应的函数正确的“柯里”。至于非固定的入参，我们后面再讲。</p>
<p>先看一个简单的实现。</p>
<p>我们来实现一个基本的 sum 方法，接受三个参数，返回加和。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来实现柯里方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// fn.length 返回需要科里化的方法的 arguments 的长度,</span></span><br><span class="line">    <span class="comment">// 如果不到这个长度，则说明需要继续接受参数，</span></span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= fn.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curried.apply(<span class="keyword">this</span>, args.concat(args2));</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现比较直观，如果长度不及原始函数规定的入参，则继续 concat，直到满足长度，调用 apply 立刻执行。</p>
<p>使用方法如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curried = curry(sum);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"curried sum result"</span>, curried(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"curried sum result"</span>, curried(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"curried sum result"</span>, curried(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p>有三个小点值得注意。</p>
<p>第一是 arguments 对象，是一个 array like object， 它拥有 length 属性，但是想直接调用数组的方法是不行的。</p>
<p>记录一下茴字的四种写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> args = [… <span class="built_in">arguments</span>]</span><br></pre></td></tr></table></figure>
<p>第二个是上面代码里的第 3 行， fn.length， 返回的是原始函数的入参长度。</p>
<p>第三，调用时，不仅可以 <code>curried(1)(2)(3)</code>, 还能<code>curried(1, 2)(3)</code>。 后者称作 partial function。有机会再聊。</p>
<p>当然市面上会有各种实现方式，配合 es5，es6，检查各种边际条件。查一查会有很多，这里不做赘述。</p>
<p>接下来聊聊柯里化的使用场景。</p>
<p>柯里化提供了一种封装方式，减少代码冗余，增加代码的可读性。</p>
<p>最常见的例子就是 log 函数，比如 log 可以接受 time ，level， message 三个参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">date, importance, message</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">`[<span class="subst">$&#123;date.getHours()&#125;</span>:<span class="subst">$&#123;date.getMinutes()&#125;</span>] [<span class="subst">$&#123;importance&#125;</span>] <span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我想在此基础上封装，logNow ，我可以这么做</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curriedLog = _.curry(log);</span><br><span class="line"></span><br><span class="line"><span class="comment">// logNow will be the partial of log with fixed first argument</span></span><br><span class="line"><span class="keyword">let</span> logNow = curriedLog(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// use it</span></span><br><span class="line">logNow(<span class="string">"INFO"</span>, <span class="string">"message"</span>); <span class="comment">// [HH:mm] INFO message</span></span><br></pre></td></tr></table></figure>
<p>或者我们想再进一步，想封装一个 debugNow 函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> debugNow = logNow(<span class="string">"DEBUG"</span>);</span><br><span class="line"></span><br><span class="line">debugNow(<span class="string">"message"</span>); <span class="comment">// [HH:mm] DEBUG message</span></span><br></pre></td></tr></table></figure>
<p>谈完了应用场景，再说说效率。</p>
<p>是的，柯里化很慢，性能损耗很大。为什么？大量的嵌套作用域和闭包，带来了不小的内存占用。至于网上说的， fn.apply 和 fn.call 比直接调用 fn 慢（看上去是的）， 老版本浏览器在 arguments.length 的实现相当慢（不知道），存取 arguments 对象比存取命名参数要慢一些（不确定），这些原因，看上去可能，但是我觉得主要原因还是内存方面。昨晚在看《函数式编程》里面，有做过柯里化和普通函数的性能对比，有空附上结果和页码。</p>
<p>最后说说前面遗留的一个问题，也是面试中常见的一道题，题目如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="number">1</span>)();</span><br><span class="line">sum(<span class="number">1</span>)(<span class="number">2</span>)();</span><br><span class="line">sum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)();</span><br></pre></td></tr></table></figure>
<p>题目大致如此，基本就是非固定的入参，求加和。关于这点，我想想说说我的看法。</p>
<p>我认为这道题要往柯里化上靠，有点勉强。放在 closure 门类里，比较合适。</p>
<p>附上我写的一个题解。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先定义一个方法，不限定入参数量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>).reduce(<span class="function">(<span class="params">p, c</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p + c;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"sum"</span>, sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry2</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 累计保存的 arguments</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 真正接受的 arguments</span></span><br><span class="line">      <span class="keyword">if</span> (!args2.length) &#123;</span><br><span class="line">        <span class="comment">// 最后传的空，告知返回结果</span></span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果入参不为空， 则继续 concat，返回 curried 方法，等待下一次调用</span></span><br><span class="line">        <span class="keyword">return</span> curried.apply(<span class="keyword">this</span>, args.concat(args2));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curried = curry2(sum);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"curried sum result"</span>, curried(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)());</span><br></pre></td></tr></table></figure>
<p>除了上述对 arguments 反复摩擦，我觉得基于 closure 的实现更加直接。主要思想就一点，也是闭包的基本概念，内层函数可以访问外层作用域。</p>
<p>实现如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m) <span class="keyword">return</span> s;</span><br><span class="line">    s += m;</span><br><span class="line">    <span class="keyword">return</span> fun;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)()); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p>这种求和方式，除了最后传入一个空以外，还有各种变体，比如给 sum 对象加一个 toString 方法，通过<code>+sum(1)</code> 来进行隐式类型转换（type coercion），那种太 hack 了，我觉得 duck 不必。</p>
<p>最后，Curry 命名不是因为咖喱，而是因为 Haskell Curry。</p>
<p>谢谢阅读。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-calendar"></i><span class="date">2021-03-24</span><i class="fa fa-tag"></i><a href="/categories/web/" title="web" class="tag">web </a><a href="/tags/javascript/" title="javascript" class="tag">javascript </a><a href="/tags/curry/" title="curry" class="tag">curry </a><a href="/tags/closure/" title="closure" class="tag">closure </a><span id="busuanzi_container_page_pv"></span> Total <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> views.</div></div></div></div><div class="share"><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"> <a href="http://twitter.com/home?status=,https://zhengminhui.github.io/23651091.html,Minhui' target="_blank" rel="noopener"s blog,聊聊柯里化,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/282aa8cf.html" title="聊聊事件循环" class="btn">prev post</a></li><li class="next pagbuttons"><a role="navigation" href="/3052b9d9.html" title="三十而立" class="btn">next post</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.1.7/dist/Valine.min.js?v=undefined"></script><script>var valine = new Valine({
  el:'#vcomments',
  visitor: true,
  notify:false || false, 
  verify:false|| false, 
  app_id:'ed7iCQax3fVhwDVnoOB6ki1i-gzGzoHsz',
  app_key:'2l1dqX729jjysNfG5uK0f0yH',
  placeholder:'_(:3 」∠ )_',
  path: window.location.pathname,
  avatar:'retro',
  lang:'en',
})</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script>var link = '';
(function() {
  $("img").each( (i,o) => {
    var o = $(o);
    var s = o.attr("src");
      // 判断图片的链接是否包含新浪或掘金的关键字
    if( s.indexOf("sinaimg") > 0 || s.indexOf('gold') > 0 ){
      // 给这个标签加上referrerPlicy属性
      o.attr("referrerpolicy","no-referrer");
        // 备份图片的src
      link = o.attr("src");
        // 重新设置src，让页面重新加载一次图片
      o.attr("src",link);
    }
  });
})();</script></body></html>