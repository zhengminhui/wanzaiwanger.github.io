<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="SuPQ3DDNV0"><meta name="author" content="Minhui Zheng, mattzhengjob@gmail.com"><title>Promise vs Observables · Minhui's blog</title><meta name="description" content="Difference
Single value vs multiple values
Eager vs lazy
Not cancellable vs cancellable
Multicast vs either unicast or multicast
Always asynchronous v"><meta name="keywords" content="Hexo,HTML,JavaScript,CSS,Frontend,Angular,React,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/custom.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-96963741-1', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Minhui's blog</a></h3><div class="description"><p>Live long and prosper.</p></div></div></div><ul class="social-links"><li><a href="https://github.com/zhengminhui" target="_blank"><i class="fa fa-github"></i></a></li><li><a href="http://instagram.com/wanzaiwanger" target="_blank"><i class="fa fa-instagram"></i></a></li><li><a href="http://weibo.com/alandwhatever" target="_blank"><i class="fa fa-weibo"></i></a></li><li><a href="http://twitter.com/wanzaiwanger" target="_blank"><i class="fa fa-twitter"></i></a></li></ul><div class="footer"><span>Theme by CaiCai & Ben</span><div class="by_farbox"><span>Proudly published with Hexo</span></div><span><i class="fa fa-user">&nbsp;</i><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></span> visitors | </span><i class="fa fa-eye">&nbsp;</i><span id="busuanzi_container_site_pv"><span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i></span> views</span></span></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="https://secure.gravatar.com/avatar/c85f5cf8f290742d2e21e929f89a5215?s=200"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Promise vs Observables</a></h3></div><div class="post-content"><h2 id="Difference"><a href="#Difference" class="headerlink" title="Difference"></a>Difference</h2><ul>
<li>Single value vs multiple values</li>
<li>Eager vs lazy</li>
<li>Not cancellable vs cancellable</li>
<li>Multicast vs either unicast or multicast</li>
<li>Always asynchronous vs possibly asynchronous</li>
</ul>
<h2 id="Single-value-vs-multiple-values"><a href="#Single-value-vs-multiple-values" class="headerlink" title="Single value vs multiple values"></a>Single value vs multiple values</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise</span></span><br><span class="line"><span class="keyword">const</span> numberPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">5</span>);</span><br><span class="line">    resolve(<span class="number">10</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// prints only 5</span></span><br><span class="line">numberPromise.then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value));</span><br><span class="line"></span><br><span class="line"><span class="comment">// observable</span></span><br><span class="line"><span class="keyword">const</span> numberObservable = <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    observer.next(<span class="number">5</span>);</span><br><span class="line">    observer.next(<span class="number">10</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// prints 5 and 10</span></span><br><span class="line">numberObservable.subscribe(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value));</span><br></pre></td></tr></table></figure>
<p>Wrapping <code>setInterval</code> in Observable: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> secondsObservable = <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        observer.next(i++);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">secondsObservable.subscribe(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value));</span><br><span class="line"><span class="comment">// logs:</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// and so on, every second</span></span><br></pre></td></tr></table></figure>
<h2 id="Eager-vs-lazy"><a href="#Eager-vs-lazy" class="headerlink" title="Eager vs lazy"></a>Eager vs lazy</h2><p>For <code>Promise</code>, the <code>executor</code> function is executed immediately by the Promise implementation, passing <code>resolve</code> and <code>reject</code> functions.</p>
<p>For <code>Observable</code>, functions passed to <code>Observable</code> constructor gets called only when someone actually subscribe to an Observable.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise print immediately</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I was called!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observable = <span class="keyword">new</span> Observable(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I was called!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// nothing happens here</span></span><br><span class="line"></span><br><span class="line">observable.subscribe();</span><br><span class="line"><span class="comment">// just now "I was called!" gets printed</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> secondsObservable = <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        observer.next(i++);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Thanks to laziness, <code>setInterval</code> is not called at this point and even <code>i</code> variable is not initiated.</p>
<h2 id="Not-cancellable-vs-cancellable"><a href="#Not-cancellable-vs-cancellable" class="headerlink" title="Not cancellable vs cancellable"></a>Not cancellable vs cancellable</h2><p>ES6 promise do not support <code>cancel</code> method. Some Promise libraries like Bluebird support <code>cancel</code> method.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> secondsObservable = <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> token = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        observer.next(i++);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(token);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscription = </span><br><span class="line">    secondsObservable.subscribe(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value));</span><br><span class="line"></span><br><span class="line">subscription.unsubscribe();</span><br></pre></td></tr></table></figure>
<p><code>subscribe</code> doesn’t return Observable! This means you cannot chain several subscribe calls like you would chain <code>then</code> calls in Promises. <code>subscribe</code> returns a Subscription for given Observable. This Subscription has only one method  – <code>unsubscribe</code>  – which you can call, when you decide you don’t want to listen to certain Observable anymore.</p>
<h2 id="Multicast-vs-either-unicast-or-multicast"><a href="#Multicast-vs-either-unicast-or-multicast" class="headerlink" title="Multicast vs either unicast or multicast"></a>Multicast vs either unicast or multicast</h2><p>Promises (because of their eager nature) are always “multicast”. Function passed to Promise constructor is called only when Promise is created and never again (unless you create brand new Promise with that function of course). </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> waitOneSecondPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I was called!'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">waitOneSecondPromise.then(doSomething);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 500ms passes</span></span><br><span class="line"></span><br><span class="line">waitOneSecondPromise.then(doSomethingElse);</span><br><span class="line"><span class="comment">// the console will print only once, and doSomethingElse will be called after only half second.</span></span><br></pre></td></tr></table></figure>
<p>That person would naturally expect doSomethingElse to be called exactly one second from the moment it was passed to then, but in that case it would be called after half a second.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> waitOneSecondObservable = <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I was called'</span>);</span><br><span class="line">  </span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> observer.next(), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">waitOneSecondObservable.subscribe(doSomething);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 500 ms</span></span><br><span class="line"></span><br><span class="line">waitOneSecondObservable.subscribe(doSomethingElse)</span><br></pre></td></tr></table></figure>
<p>Here every call to <code>subscribe</code> will start it’s own clock. Both doSomething and doSomethingElse functions will be called one second from the moment they were passed to <code>subscribe</code>. If you look in the console, you will see <code>&quot;I was called!&quot;</code> printed to console twice, which shows that function passed to <code>Observable</code> constructor was indeed called twice and two instances of <code>setTimeout</code> timer were created.</p>
<p>By using <code>share</code> operator, you can make the <code>Observable</code> perform only once and then share between subscribers.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sharedWaitOneSecondObservable =</span><br><span class="line">    waitOneSecondObservable.share();</span><br><span class="line"></span><br><span class="line">sharedWaitOneSecondObservable.subscribe(doSomething);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 500 ms passes</span></span><br><span class="line"></span><br><span class="line">sharedWaitOneSecondObservable.subscribe(doSomethingElse);</span><br></pre></td></tr></table></figure>
<p>If Observable shares a result between many subscribers, we say it is “multicast”, since it casts single value to multiple entities.</p>
<h2 id="Always-asynchronous-vs-possibly-asynchronous"><a href="#Always-asynchronous-vs-possibly-asynchronous" class="headerlink" title="Always asynchronous vs possibly asynchronous"></a>Always asynchronous vs possibly asynchronous</h2><p>Promise is asynchronous even we call <code>resolve</code> synchronously.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value + <span class="string">'!'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'And now we are here.'</span>);</span><br></pre></td></tr></table></figure>
<p>First <code>&quot;And now we are here.&quot;</code> is logged and just then <code>&quot;5!&quot;</code></p>
<p>Observable may emit values synchronously.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observable = <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    observer.next(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">observable.subscribe(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value + <span class="string">'!'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'And now we are here.'</span>);</span><br></pre></td></tr></table></figure>
<p><code>&quot;5!&quot;</code> appears first and just then we see <code>&quot;And now we are here.&quot;</code>.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://medium.com/@mpodlasin/promises-vs-observables-4c123c51fe13" target="_blank" rel="noopener">promises-vs-observables</a></li>
</ol>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-calendar"></i><span class="date">2019-01-27</span><i class="fa fa-tag"></i><a href="/categories/web/" title="web" class="tag">web </a><a href="/tags/ECMAScript2015/" title="ECMAScript2015" class="tag">ECMAScript2015 </a><a href="/tags/es6/" title="es6" class="tag">es6 </a><a href="/tags/promise/" title="promise" class="tag">promise </a><a href="/tags/Observables/" title="Observables" class="tag">Observables </a><a href="/tags/subscription/" title="subscription" class="tag">subscription </a><a href="/tags/subscribe/" title="subscribe" class="tag">subscribe </a><span id="busuanzi_container_page_pv"></span> Total <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> views.</div></div></div></div><div class="share"><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"> <a href="http://twitter.com/home?status=,https://zhengminhui.github.io/24019ac5.html,Minhui' target="_blank" rel="noopener"s blog,Promise vs Observables,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/c505c167.html" title="Node.js modules" class="btn">prev post</a></li><li class="next pagbuttons"><a role="navigation" href="/89c05b44.html" title="Decorators in JavaScript" class="btn">next post</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.1.7/dist/Valine.min.js?v=undefined"></script><script>var valine = new Valine({
  el:'#vcomments',
  visitor: true,
  notify:false || false, 
  verify:false|| false, 
  app_id:'ed7iCQax3fVhwDVnoOB6ki1i-gzGzoHsz',
  app_key:'2l1dqX729jjysNfG5uK0f0yH',
  placeholder:'_(:3 」∠ )_',
  path: window.location.pathname,
  avatar:'retro',
  lang:'en',
})</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script>var link = '';
(function() {
  $("img").each( (i,o) => {
    var o = $(o);
    var s = o.attr("src");
      // 判断图片的链接是否包含新浪或掘金的关键字
    if( s.indexOf("sinaimg") > 0 || s.indexOf('gold') > 0 ){
      // 给这个标签加上referrerPlicy属性
      o.attr("referrerpolicy","no-referrer");
        // 备份图片的src
      link = o.attr("src");
        // 重新设置src，让页面重新加载一次图片
      o.attr("src",link);
    }
  });
})();</script></body></html>